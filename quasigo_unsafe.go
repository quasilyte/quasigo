package quasigo

import (
	"unsafe"

	"github.com/quasilyte/quasigo/internal/qruntime"
)

// addb returns the byte pointer p+n.
//go:nosplit
func addb(p *byte, n uintptr) *byte {
	// Note: wrote out full expression instead of calling add(p, n)
	// to reduce the number of temporaries generated by the
	// compiler for this trivial expression during inlining.
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
}

//go:nosplit
func add(p unsafe.Pointer, x uintptr) unsafe.Pointer {
	return unsafe.Pointer(uintptr(p) + x)
}

//go:nosplit
func unpack16(code *byte, pc int) int {
	ptr := addb(code, uintptr(pc))
	return int(int16(uint16(*ptr) | uint16(*addb(ptr, 1))<<8))
}

//go:nosplit
func unpack8(code *byte, pc int) byte {
	return *addb(code, uintptr(pc))
}

//go:nosplit
func unpack8x2(code *byte, pc int) (byte, byte) {
	ptr := addb(code, uintptr(pc))
	return *ptr, *(addb(ptr, 1))
}

//go:nosplit
func unpack8x3(code *byte, pc int) (byte, byte, byte) {
	ptr := addb(code, uintptr(pc))
	return *ptr, *(addb(ptr, 1)), *(addb(ptr, 2))
}

//go:nosplit
func unpack8x4(code *byte, pc int) (byte, byte, byte, byte) {
	ptr := addb(code, uintptr(pc))
	return *ptr, *(addb(ptr, 1)), *(addb(ptr, 2)), *(addb(ptr, 3))
}

//go:nosplit
func getslot(slotptr *qruntime.Slot, index byte) *qruntime.Slot {
	return (*qruntime.Slot)(add(unsafe.Pointer(slotptr), qruntime.SizeofSlot*uintptr(index)))
}

//go:nosplit
func slotoffset(base, current *qruntime.Slot) int {
	return int((uintptr(unsafe.Pointer(current)) - uintptr(unsafe.Pointer(base))) / qruntime.SizeofSlot)
}

//go:nosplit
func canAllocFrame(current, end *qruntime.Slot, frameSize int) bool {
	return uintptr(unsafe.Pointer(current))+uintptr(frameSize) < uintptr(unsafe.Pointer(end))
}

//go:nosplit
func nextFrameSlot(current *qruntime.Slot, frameSize int) *qruntime.Slot {
	return (*qruntime.Slot)(add(unsafe.Pointer(current), uintptr(frameSize)))
}
