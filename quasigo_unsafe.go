package quasigo

import (
	"unsafe"
)

const sizeofSlotValue = unsafe.Sizeof(slotValue{})

// Works for both empty and non-empty interfaces.
type goIface struct {
	typeinfo uint64
	data     unsafe.Pointer
}

type goString struct {
	data unsafe.Pointer
	len  int
}

type goSlice struct {
	data unsafe.Pointer
	len  int
	cap  int
}

type slotValue struct {
	ptr     unsafe.Pointer
	scalar  uint64
	scalar2 uint64
}

func (slot slotValue) IsNil() bool {
	return slot.ptr == nil
}

func (slot slotValue) IsNilInterface() bool {
	return slot.ptr == nil && slot.scalar == 0
}

func (slot *slotValue) SetBool(v bool) {
	if v {
		slot.scalar = 1
	} else {
		slot.scalar = 0
	}
}

func (slot slotValue) Bool() bool {
	return *(*bool)(unsafe.Pointer(&slot.scalar))
}

func (slot *slotValue) MoveInterface(src *slotValue) {
	slot.ptr = src.ptr
	slot.scalar = src.scalar
}

func (slot *slotValue) SetInterface(v interface{}) {
	raw := (*goIface)(unsafe.Pointer(&v))
	slot.ptr = raw.data
	slot.scalar = raw.typeinfo
}

func (slot slotValue) Interface() interface{} {
	v := goIface{
		typeinfo: slot.scalar,
		data:     slot.ptr,
	}
	return *(*interface{})(unsafe.Pointer(&v))
}

func (slot *slotValue) SetString(v string) {
	raw := *(*goString)(unsafe.Pointer(&v))
	slot.ptr = raw.data
	slot.scalar = uint64(raw.len)
}

func (slot slotValue) String() string {
	return *(*string)(unsafe.Pointer(&slot))
}

func (slot *slotValue) SetInt(v int) {
	slot.scalar = uint64(v)
}

func (slot slotValue) Int() int { return int(slot.scalar) }

// addb returns the byte pointer p+n.
//go:nosplit
func addb(p *byte, n uintptr) *byte {
	// Note: wrote out full expression instead of calling add(p, n)
	// to reduce the number of temporaries generated by the
	// compiler for this trivial expression during inlining.
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
}

//go:nosplit
func add(p unsafe.Pointer, x uintptr) unsafe.Pointer {
	return unsafe.Pointer(uintptr(p) + x)
}

//go:nosplit
func unpack16(code *byte, pc int) int {
	ptr := addb(code, uintptr(pc))
	return int(int16(uint16(*ptr) | uint16(*addb(ptr, 1))<<8))
}

//go:nosplit
func unpack8(code *byte, pc int) byte {
	return *addb(code, uintptr(pc))
}

//go:nosplit
func unpack8x2(code *byte, pc int) (byte, byte) {
	ptr := addb(code, uintptr(pc))
	return *ptr, *(addb(ptr, 1))
}

//go:nosplit
func unpack8x3(code *byte, pc int) (byte, byte, byte) {
	ptr := addb(code, uintptr(pc))
	return *ptr, *(addb(ptr, 1)), *(addb(ptr, 2))
}

//go:nosplit
func unpack8x4(code *byte, pc int) (byte, byte, byte, byte) {
	ptr := addb(code, uintptr(pc))
	return *ptr, *(addb(ptr, 1)), *(addb(ptr, 2)), *(addb(ptr, 3))
}

//go:nosplit
func getslot(slotptr *slotValue, index byte) *slotValue {
	return (*slotValue)(add(unsafe.Pointer(slotptr), sizeofSlotValue*uintptr(index)))
}

//go:nosplit
func slotoffset(base, current *slotValue) int {
	return int((uintptr(unsafe.Pointer(current)) - uintptr(unsafe.Pointer(base))) / sizeofSlotValue)
}

//go:nosplit
func canAllocFrame(current, end *slotValue, frameSize int) bool {
	return uintptr(unsafe.Pointer(current))+uintptr(frameSize) < uintptr(unsafe.Pointer(end))
}

//go:nosplit
func nextFrameSlot(current *slotValue, frameSize int) *slotValue {
	return (*slotValue)(add(unsafe.Pointer(current), uintptr(frameSize)))
}
